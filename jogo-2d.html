<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jogo de Corrida 2D (Top-Down)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #87ceeb;
      font-family: Arial, sans-serif;
    }

    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 20px;
      z-index: 10;
      text-shadow: 0 0 5px black;
    }

    #gameOverScreen {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      font-size: 40px;
      font-weight: bold;
      text-align: center;
      padding-top: 30vh;
      z-index: 100;
      user-select: none;
    }
  </style>
</head>

<body>

  <div id="hud">
    Tempo: <span id="tempo">0</span> | Pontuação: <span id="pontos">0</span>
  </div>

  <div id="gameOverScreen">Game Over!<br>Sua pontuação: <span id="finalScore">0</span><br><br><button
      onclick="location.reload()">Jogar Novamente</button></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

  <script>
    // Sons
    const trafficSound = new Audio('Carro.mp3');
    trafficSound.loop = true;
    trafficSound.volume = 1.0;

    const crashSound = new Audio('Batida.mp3');
    crashSound.volume = 1.0;

    // Variável para controlar se áudio já iniciou
    let audioStarted = false;

    // Função para iniciar o som após interação do usuário
    function startAudio() {
      if (!audioStarted) {
        trafficSound.play().catch(() => {
          // Se ainda falhar, ignora
        });
        audioStarted = true;
      }
    }

    // Espera o primeiro input do usuário para liberar o som
    window.addEventListener('keydown', startAudio, { once: true });
    window.addEventListener('click', startAudio, { once: true });

    // Cena e câmera ortográfica
    const scene = new THREE.Scene();
    const aspect = window.innerWidth / window.innerHeight;
    const camera = new THREE.OrthographicCamera(-10 * aspect, 10 * aspect, 10, -10, 0.1, 100);
    camera.position.set(0, 0, 10); // Visão de cima
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Pista (fundo preto)
    const pistaGeo = new THREE.PlaneGeometry(20, 200);
    const pistaMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
    const pista = new THREE.Mesh(pistaGeo, pistaMat);
    pista.position.y = 0;
    scene.add(pista);

    // Linhas laterais
    const lineGeo = new THREE.PlaneGeometry(0.2, 200);
    const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const lineLeft = new THREE.Mesh(lineGeo, lineMat);
    lineLeft.position.set(-10, 0, 0.01);
    scene.add(lineLeft);

    const lineRight = lineLeft.clone();
    lineRight.position.x = 10;
    scene.add(lineRight);

    // Carrinho (fixo na parte inferior)
    const cartGeo = new THREE.BoxGeometry(2, 4, 0.1);
    const cartMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const cart = new THREE.Mesh(cartGeo, cartMat);
    cart.position.set(0, -6, 0.1); // Z maior que obstáculos para sobrepor
    scene.add(cart);

    // Obstáculos
    const obstacles = [];
    const obsGeo = new THREE.BoxGeometry(2, 2, 0.1);
    const obsMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    let lastObstacleY = 30; // Começa no topo

    function spawnObstacle() {
      const obs = new THREE.Mesh(obsGeo, obsMat);
      obs.position.z = 0;

      lastObstacleY += 15 + Math.random() * 20;
      obs.position.y = lastObstacleY;
      obs.position.x = (Math.random() * 16) - 8;

      scene.add(obs);
      obstacles.push(obs);
    }

    for (let i = 0; i < 20; i++) spawnObstacle();

    // Controles
    const keys = {};
    window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    // Variáveis de jogo
    const speed = 0.3;
    let pontos = 0;
    let tempo = 0;
    let gameOver = false;

    const pontosDisplay = document.getElementById('pontos');
    const tempoDisplay = document.getElementById('tempo');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScore = document.getElementById('finalScore');

    // Colisão simples (2D)
    function colisao(obj1, obj2, dist) {
      const dx = obj1.position.x - obj2.position.x;
      const dy = obj1.position.y - obj2.position.y;
      return (dx * dx + dy * dy) < (dist * dist);
    }

    function finishGame() {
      gameOver = true;
      finalScore.textContent = Math.floor(pontos);
      gameOverScreen.style.display = 'block';

      trafficSound.pause();  // Para som ambiente
      crashSound.play();     // Toca som de colisão
    }

    function animate() {
      if (gameOver) return;
      requestAnimationFrame(animate);

      // Movimento lateral do carrinho
      if (keys['arrowleft'] || keys['a']) {
        cart.position.x -= 0.3;
      }
      if (keys['arrowright'] || keys['d']) {
        cart.position.x += 0.3;
      }

      // Limitar carrinho à pista
      cart.position.x = Math.max(-8, Math.min(8, cart.position.x));

      // Mover obstáculos para baixo
      obstacles.forEach(obs => {
        obs.position.y -= speed;

        if (obs.position.y < -12) {
          lastObstacleY += 15 + Math.random() * 20;
          obs.position.y = lastObstacleY;
          obs.position.x = (Math.random() * 16) - 8;
        }

        // Verificar colisão
        if (colisao(cart, obs, 2)) {
          finishGame();
        }
      });

      // Pontuação
      pontos += speed;
      pontosDisplay.textContent = Math.floor(pontos);

      renderer.render(scene, camera);
    }

    animate();

    // Cronômetro
    const timer = setInterval(() => {
      if (gameOver) {
        clearInterval(timer);
        return;
      }
      tempo++;
      tempoDisplay.textContent = tempo;
    }, 1000);

    // Resize da tela
    window.addEventListener('resize', () => {
      const aspect = window.innerWidth / window.innerHeight;
      camera.left = -10 * aspect;
      camera.right = 10 * aspect;
      camera.top = 10;
      camera.bottom = -10;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>

</body>

</html>

